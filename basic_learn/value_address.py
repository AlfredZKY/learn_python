#!/usr/bin/env python
# -*- coding: utf-8 -*-
# @File:value_address.py
# @Author: Feng
# @Date:2019/8/7
# @Desc:

# Python 里的对象可以被多个变量所指向或引用。
# Python 的数据类型，例如整型（int）、字符串（string)等是不可变的
# 所以 a= a+1 ,并不是让a 的值增加1，而是表示重新创建了一个新的值为2的对象，并让a指向它
# 但是b仍然不变，仍然指向1这个对象
# a和b开始只表示两个指向同一个对象的变量而已，并不表示重新创建了新对象
# 只是让同一个对象被多个变量指向或引用
a = 1
b = a
a = a + 1

l1 = [1, 2, 3, 4]
l2 = l1
# 列表是可变的，添加操作不会创建新的列表。
l1.append(5)
print(l1)
print(l2)

# python 里的变量是可以被删除，但是对象无法被删除。
l3 = [1, 2, 3]
del l3


# 删除l3这个变量后，从此就无法访问l3，但是对象[1,2,3]仍然还在
# Python自带的垃圾回收系统会跟踪每个对象的引用。如果[1,2,3]除了l3外，还在其他地方被引用，那它就不会被回收，反之就会被回收

# 由此可见，在Python中：
#   1.变量的赋值，只是表示让变量指向了某个对象，并不表示拷贝对象给变量，而一个对象可以被多个变量指向
#   2.可变对象(列表，字典，集合等等)的改变，会改变所有指向该对象的变量
#   3.对于不可变对象(字符串，整型，元组等等)，所有指向该对象的变量的值总是一样的，也不会改变
#       但是通过某些操作(+=等等)更新不可变对象的值时，会返回一个新的对象
#   4.变量可以被删除，但是对象无法被删除

def my_func2(l2):
    # 这里是新创建了一个列表对象，并让l2变量指向它
    l2 = l2 + [4]


l1 = [1, 2, 3]
my_func2(l1)
print(l1)


def my_func5(l2):
    l2 = l2 + [4]
    return l2


l1 = my_func5(l1)
print(l1)

l1 = [1, 2, 3]
l2 = [1, 2, 3]
l3 = l2

print(id(l1), id(l2), id(l3))

d = {'a': 1, 'b': 2}


def func(d):
    d['a'] = 10
    d['b'] = 20


func(d)
print(d)
